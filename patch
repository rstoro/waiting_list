commit 60379e664d4a2e0ba71c45d2773c76490dbc232c
Author: Ryan Storo <ryanstoro@gmail.com>
Date:   Tue Mar 2 12:48:36 2021 -0500

    show-noshow doughnut chart complete on analytics page.

diff --git a/src/components/Analytics.vue b/src/components/Analytics.vue
index f471ab4..22ef43c 100644
--- a/src/components/Analytics.vue
+++ b/src/components/Analytics.vue
@@ -4,7 +4,7 @@
     <div slot="header">
       <div class="analytics-header">
         <div class="analytics-header-row">
-          <Calendar v-bind:is-range="true" v-on:dateSelected="getLogData"/>
+          <Calendar v-bind:is-range="false" v-on:dateSelected="loadLogdata"/>
         </div>
         <!--
         <div class="analytics-header-row">
@@ -27,15 +27,27 @@
         -->
       </div>
     </div>
-    <div slot="body">
-      {{ avgWaitTime }}
-      {{ avgTravelTime }}
-      {{ avgOnListTime }}
-      {{ showNoShowRatio }}
-      {{ percentageShowed }}
-      {{ percentageNoShowed }}
+    <div slot="body" class="analytics-body">
+      <div class="columns is-multiline is-mobile" v-if="chartData.length !== 0">
+        <div class="column is-half">
+          <doughnut-chart v-bind:chart-data="showedNoShowedChartData"
+                          v-bind:center-text="showedNoShowedChartText"></doughnut-chart>
+        </div>
+        <div class="column is-one-quarter">
+          wow
+        </div>
+        <div class="column is-one-quarter">
+          wow2
+        </div>
+        <div class="column is-full">
+          wow3
+        </div>
+      </div>
       <!--<bar-chart></bar-chart>
       <line-chart></line-chart>-->
+      <div class="true-center" v-else>
+        <span class="has-text-grey">{{ noDataExistText() }}</span>
+      </div>
     </div>
   </Page>
 
@@ -48,6 +60,9 @@ import Calendar from './calendar/Calendar.vue';
 import Dropdown from './dropdown/Dropdown.vue';
 import LineChart from './charts/LineChart.vue';
 import BarChart from './charts/BarChart.vue';
+import DoughnutChart from './charts/DoughnutChart.vue';
+
+let logdate;
 
 export default {
   name: 'Analytics',
@@ -57,7 +72,8 @@ export default {
     Calendar,
     Dropdown,
     LineChart,
-    BarChart
+    BarChart,
+    DoughnutChart 
   },
   data() {
     // TODO: chart data types: time, date, wait:message, message:arrival, wait:arrival
@@ -65,82 +81,87 @@ export default {
     //       chart types: bar, graph, doughnut, scatter with best fit (do we need others?)
     //       data to be displayed: averages (what else?)
     return {
-      avgWaitTime: 0,
-      avgTravelTime: 0,
-      avgOnListTime: 0,
-      showNoShowRatio: 0,
-      percentageShowed: 0,
-      percentageNoShowed: 0
+      showedNoShowedChartText: '',
+      showedNoShowedChartData: {},
+      chartData: []
     }
   },
   methods: {
-    getLogData(dateRange) {
-      // load actionsDict from logs
-      const startDate = dateRange[0];
-      const endDate = dateRange[1];
-      const actionsDict = {};
-
-      // NOTE: time-on-list is equal to showed plus noShowed
-      const tData = {
-        'waitTime': { 'val': 0, 'count': 0, 'keys': [
-          { 'pk': 'SENT', 'fk': 'CREATE' }
-        ]},
-        'travelTime': { 'val': 0, 'count': 0, 'keys': [
-          { 'pk': 'ARRIVE', 'fk': 'SENT' }
-        ]},
-        'showed': { 'val': 0, 'count': 0, 'keys': [
-          { 'pk': 'ARRIVE', 'fk': 'CREATE' }
-        ]},
-        'noShowed': { 'val': 0, 'count': 0, 'keys': [
-          { 'pk': 'DELETE', 'fk': 'CREATE' }
-        ]}
-      }
-
-      // NOTE: logs are ALWAYS sequential
-      this.getLogs(startDate, endDate).forEach(logfile => {
-        logfile.forEach(log => {
-          const newTime = this.getSecondsFromTimestamp(log.time);
-
-          // set new action for user
-          if (log.id in actionsDict) {
-            actionsDict[log.id][log.action] = newTime;
-          }
-          else {
-            actionsDict[log.id] = { [log.action]: newTime };
-          }
-
-          // check to see if we can update our tData 
-          for (const dataType in tData) {
-            tData[dataType]['keys'].forEach( key => {
+    loadLogdata(newDate) {
+      // set prev
+      logdate = newDate;
 
-              // check to see if the pk matches the current key
-              if (log.action === key['pk']) {
+      // reset chartData
+      this.chartData = [];
 
-                // update the count of the acc
-                tData[dataType]['count'] += 1;
+      // NOTE: time-on-list is equal to showed plus noShowed
+      const logs = this.getLog(logdate);
 
-                // add to the cumulative value
-                const timeDiff = newTime - actionsDict[log.id][key['fk']];
-                tData[dataType]['val'] += timeDiff;
-              }
-            });
-          }
+      // early out
+      if (logs === null) {
+        return;
+      }
 
-        });
+      logs.forEach(log => {
+        const currentUser = this.chartData.find(user => user.id === log.id);
+        if (currentUser === null || currentUser === undefined) {
+          this.chartData.push({
+            'id': log.id,
+            'fullname': log.fullname,
+            'phonenumber': log.phonenumber,
+            'actions': { [log.action]: log.time.split(' ')[0] }
+          });
+        }
+        else {
+          currentUser.actions[log.action] = log.time.split(' ')[0];
+        }
       });
 
       // populate data
-      const tCount = tData['showed']['count'] + tData['noShowed']['count'];
-      this.avgOnListTime = (tData['showed']['val'] + tData['noShowed']['val']) / tCount;
+      const showedCount = this.chartData.reduce( (acc, user) => {
+        return user['actions']['ARRIVE'] ? acc + 1 : acc;
+      }, 0);
+      const noShowedCount = this.chartData.length - showedCount;
+      this.showedNoShowedChartData = this.buildShowedNoShowedChartData(
+        showedCount,
+        noShowedCount
+      );
+      this.showedNoShowedChartText = this.getShowedNoShowedRatio(
+        showedCount,
+        noShowedCount
+      );
+
+      /*
+      this.avgOnListTime = (tData['showed']['val'] + tData['noShowed']['val']) / (tData['showed']['count'] + tData['noShowed']['count']);
       this.avgWaitTime = tData['waitTime']['val'] / tData['waitTime']['count'];
       this.avgTravelTime = tData['travelTime']['val'] / tData['travelTime']['count'];
       this.showNoShowRatio = `${tData['showed']['count']}:${tData['noShowed']['count']}`;
-      this.percentageShowed = tData['showed']['count'] / tCount * 100;
-      this.percentageNoShowed = tData['noShowed']['count'] / tCount * 100;
+      */
+
     },
     getSecondsFromTimestamp(t) {
       const [hours, minutes, seconds] = t.split(' ')[0].split(':').map(n => parseInt(n));
       return hours * 60 * 60 + minutes * 60 + seconds;
+    },
+    getShowedNoShowedRatio(showed, noShowed) {
+      const total = showed + noShowed;
+      const showedPercentage = showed === 0 ? 0 : Math.round((showed / total) * 100);
+      return `${showedPercentage}%`;
+    },
+    buildShowedNoShowedChartData(showed, noShowed) {
+      return {
+        labels: ['Showed', 'No Showed'],
+        datasets: [
+          {
+            borderWidth: 0,
+            backgroundColor: ['#48c774', '#f14668'],
+            data: [ showed, noShowed ]
+          }
+        ]
+      }
+    },
+    noDataExistText() {
+      return `There is no data for ${new Date(logdate).toDateString()}.`;
     }
   }
 }
@@ -163,6 +184,9 @@ export default {
 .analytics-header > .analytics-header-row > *:not(:last-child) {
   padding-right: 8px;
 }
+.analytics-body {
+  height: 100%;
+}
 .true-center {
   display:flex;
   flex-flow: column;
diff --git a/src/components/Audit.vue b/src/components/Audit.vue
index 5fb849e..0e5ee9f 100644
--- a/src/components/Audit.vue
+++ b/src/components/Audit.vue
@@ -2,7 +2,7 @@
 
   <Page>
     <div slot="header" class="audit-header">
-      <Calendar v-on:dateSelected="get"/>
+      <Calendar v-on:dateSelected="loadLogdata"/>
       <div class="filter field">
         <p class="control has-icons-left">
           <span class="filter-icon icon has-text-info is-left">
@@ -55,7 +55,7 @@ import Storage from '../mixins/storage.js';
 import Page from './base/Page.vue';
 import Calendar from './calendar/Calendar.vue';
 
-let logdate = null;
+let logdate;
 
 export default {
   name: 'Audit',
@@ -81,7 +81,7 @@ export default {
     }
   },
   methods: {
-    get(newLogdate) {
+    loadLogdata(newLogdate) {
       logdate = newLogdate;
       this.users = [];
 
diff --git a/src/components/charts/DoughnutChart.vue b/src/components/charts/DoughnutChart.vue
new file mode 100644
index 0000000..47b9773
--- /dev/null
+++ b/src/components/charts/DoughnutChart.vue
@@ -0,0 +1,67 @@
+<script>
+import { Doughnut } from 'vue-chartjs';
+
+export default {
+  extends: Doughnut,
+  props: {
+    centerText: {
+      type: String,
+      default: ''
+    },
+    chartData: {
+      type: Object,
+      default: { 
+        labels: ['No Data'],
+        datasets: [{ 
+          borderWidth: 0,
+          backgroundColor: '#f14668', //[ '#48c774', '#ffdd57', '#f14668' ]
+          data: [100]
+        }]
+      }
+    }
+  },
+  data() {
+    return {
+      options: {
+        legend: { display: true },
+        responsive: true,
+        maintainAspectRatio: false
+      }
+    }
+  },
+  mounted() {
+    // I love JS scopes...
+    const vm = this;
+    vm.addPlugin({
+      id: 'draw-text',
+      beforeDraw: function(chart) {
+        const ctx = chart.chart.ctx;
+        const elemWidth = (chart.innerRadius * 2) - (0.50 * (chart.innerRadius * 2));
+        const strWidth = ctx.measureText(vm.centerText).width;
+        const fontSize = Math.floor(elemWidth / strWidth);
+        
+        ctx.restore();
+        ctx.font = fontSize + 'em Avenir, Helvetica, Arial, sans-serif';
+        ctx.textAlign = 'center';
+        ctx.textBaseline = 'middle';
+        ctx.fillStyle = '#3273dc';
+        ctx.fillText(
+          vm.centerText,
+          (chart.chartArea.left + chart.chartArea.right) / 2,
+          (chart.chartArea.top + chart.chartArea.bottom) / 2
+        );
+        ctx.save();
+      }
+    });
+    this.renderChart(this.chartData, this.options);
+  },
+  watch: {
+    chartData() {
+      this.renderChart(this.chartData, this.options);
+    },
+    centerText() {
+      this.renderChart(this.chartData, this.options);
+    }
+  }
+}
+</script>
diff --git a/tmp.txt b/tmp.txt
new file mode 100644
index 0000000..23e8956
--- /dev/null
+++ b/tmp.txt
@@ -0,0 +1,81 @@
+  beforeDraw: function(chart) {
+    if (chart.config.options.elements.center) {
+      // Get ctx from string
+      const ctx = chart.chart.ctx;
+
+      // Get options from the center object in options
+      const centerConfig = chart.config.options.elements.center;
+      const fontStyle = centerConfig.fontStyle || 'Arial';
+      const txt = centerConfig.text;
+      const color = centerConfig.color || '#000';
+      const maxFontSize = centerConfig.maxFontSize || 75;
+      const sidePadding = centerConfig.sidePadding || 20;
+      const sidePaddingCalculated = (sidePadding / 100) * (chart.innerRadius * 2)
+      // Start with a base font of 30px
+      ctx.font = "30px " + fontStyle;
+
+      // Get the width of the string and also the width of the element minus 10 to give it 5px side padding
+      const stringWidth = ctx.measureText(txt).width;
+      const elementWidth = (chart.innerRadius * 2) - sidePaddingCalculated;
+
+      // Find out how much the font can grow in width.
+      const widthRatio = elementWidth / stringWidth;
+      const newFontSize = Math.floor(30 * widthRatio);
+      const elementHeight = (chart.innerRadius * 2);
+
+      // Pick a new font size so it will not be larger than the height of label.
+      const fontSizeToUse = Math.min(newFontSize, elementHeight, maxFontSize);
+      const minFontSize = centerConfig.minFontSize;
+      const lineHeight = centerConfig.lineHeight || 25;
+      let wrapText = false;
+
+      if (minFontSize === undefined) {
+        minFontSize = 20;
+      }
+
+      if (minFontSize && fontSizeToUse < minFontSize) {
+        fontSizeToUse = minFontSize;
+        wrapText = true;
+      }
+
+      // Set font settings to draw it correctly.
+      ctx.textAlign = 'center';
+      ctx.textBaseline = 'middle';
+      let centerX = ((chart.chartArea.left + chart.chartArea.right) / 2);
+      let centerY = ((chart.chartArea.top + chart.chartArea.bottom) / 2);
+      ctx.font = fontSizeToUse + "px " + fontStyle;
+      ctx.fillStyle = color;
+
+      if (!wrapText) {
+        ctx.fillText(txt, centerX, centerY);
+        return;
+      }
+
+      const words = txt.split(' ');
+      let line = '';
+      const lines = [];
+
+      // Break words up into multiple lines if necessary
+      for (const n = 0; n < words.length; n++) {
+        const testLine = line + words[n] + ' ';
+        const metrics = ctx.measureText(testLine);
+        const testWidth = metrics.width;
+        if (testWidth > elementWidth && n > 0) {
+          lines.push(line);
+          line = words[n] + ' ';
+        } else {
+          line = testLine;
+        }
+      }
+
+      // Move the center up depending on line height and number of lines
+      centerY -= (lines.length / 2) * lineHeight;
+
+      for (const n = 0; n < lines.length; n++) {
+        ctx.fillText(lines[n], centerX, centerY);
+        centerY += lineHeight;
+      }
+      //Draw text in center
+      ctx.fillText(line, centerX, centerY);
+    }
+  }
